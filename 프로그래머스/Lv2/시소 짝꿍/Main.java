/*
 * 문제를 주의깊게 읽어야 한다....
 * 시소에 존재하는 자리가 2 3 4 밖에 없음 1이 없기 때문에 짝꿍이 될 수 있는 수가 그에 따라 결정됨
 * 예를 들어 몸무게가 120인 사람의 경우
 * 2 -> 120(2/2) 80(2/3) 60(2/4)
 * 3 -> 180(3/2) 120(3/3) 90(3/4)
 * 4 -> 240(4/2) 180(4/3) 120(4/4)
 * 위 몸무게에 해당하는 사람들과 짝을 이룰 수 있음 
 * 
 * 중복을 제거해야 함
 * 만약 위 후보를 전부 다 취급하게 되면 중복이 발생할 수 있음 그래서 본인보다 크거나 작은 수만을 취급하게 해야 함
 * 결과적으로 가능한 후보는 1, 3/2, 4/3, 2 이렇게 네 가지임
 * 
 * 구현하는 방법
 * 10만이기 때문에 O(NlogN)의 까지 가능함 그래서 이진 탐색으로 구현하면 시간은 아마 될 듯..?
 * 근데 귀찮음 그래서 몸무게가 100~1000까지니까 각 몸무게에 해당하는 사람의 수를 세서 조합을 생성하면 편함
 * 
 * 경우의 수 구하기
 * 본인의 몸무게와 
 * - 같은 사람의 경우 : n개에서 2개 뽑기 하면 됨(n(n-1)/2)
 * - 다른 사람의 경우 : n개에서 하나 m개에서 하나 뽑으면 됨 (n * m)
 * 
 * 주의할 점
 * 몸무게의 갯수가 10만이 최대임 카운트할 땐 int 범위를 넘지 않지만 조합을 구하는 과정에선 
 * 10만의 제곱으로 100억까지 나올 수 있기 때문에 몸무게 갯수 배열을 long으로 선언해줘야 함
 */

class Solution {

	public long solution(int[] weights) {

		long[] candi = new long[1001];
		for (int weight : weights) {
			candi[weight]++;
		}

		long answer = 0;
		for (int i = 100; i < 1001; i++) {

			answer += candi[i] * (candi[i] - 1) / 2;

			if (i % 2 == 0 && i / 2 * 3 < 1001) {
				answer += candi[i] * candi[i / 2 * 3];
			}

			if (i % 3 == 0 && i / 3 * 4 < 1001) {
				answer += candi[i] * candi[i / 3 * 4];
			}

			if (i * 2 < 1001) {
				answer += candi[i] * candi[2 * i];
			}
		}

		return answer;
	}
}