import java.util.Stack;

/*
 * 현재 위치를 기준으로 뒤의 값들을 매 원소마다 조회하면 시간 초과 발생함 (N^2)
 * 그래서 O(NlogN) 이하의 방법이 필요함 불필요한 비교를 최대한 제거하는 방식이 필요함
 * 
 * 뒤부터 순회하면서 앞 숫자보다 클 수 있는 수의 후보군을 저장하면 됨
 * 앞에 어떤 숫자가 나올지 모르지만 만약 N+1번째 숫자가 N번째 숫자보다 작다면
 * N+1번째 숫자는 불필요함 앞 숫자가 뭐던간에 N이 들어갈 예정이기 때문임
 * 예를 들어 [2, 1, 5, 3, 6, 5]에서 3에 들어갈 숫자는 6임 6을 조회한 순간부터 5는
 * 이후로 영영 필요없음 이런 식으로 만약 후보군에 저장된 값이 현재 비교되는 값보다 작다면 제거하는
 * 방식으로 구현하는 것임
 * 
 * 간단한 동작 흐름
 * 0. 뒤부터 시작함 5는 후보군에 저장
 * 1. 후보군의 마지막과 6을 비교함 5 < 6이기 때문에 5는 지움 (stack이 비었기 때문에 종료) 6을 후보군에 저장
 * 2. 후보군의 마지막과 3을 비교함 3 < 6이기 때문에 (큰 값을 찾았기 때문에 종료) 3을 후보군에 추가
 * 3. 후보군의 마지막과 5를 비교함 5 > 3이기 때문에 3을 지움 5 < 6 이기 때문에 (큰 값을 찾았기 때문에 종료) 5를 후보군에 추가
 * ...
 * 이런 식으로 현재 값과 후보군들을 비교하면서 현재 값이 더 크면 기존에 저장되어 있던 값을 지우는 방식
 *  
 * Stack을 이용하면 이 구현이 편함
 * 배열을 이용할 경우 0에 대한 처리가 꽤나 번거로움
 * - 보통의 경우엔 배열을 선언해두고 count를 둬서 값을 변경하거나 무시하는 방식으로 구현
 * - 반면에 후보군에 하나만 저장된 상황에서 후보군보다 큰 값이 하나 존재함 이때 count가 0 - 1로 음수를 가지게 됨
 * - 이런 상황을 보통의 상황과 구분지어서 처리해야되서 번거로움
 * 
 * 시간복잡도
 * 이런 식으로 모든 원소를 순회한다고 하면 각 원소마다 Stack에 저장된 모든 원소를 조회하는 것이 최악의 경우기 때문에
 * O(N^2)이라고 생각할 수 있음 하지만 실제로는 모든 원소마다 동일한 Stack을 확인하는게 아니라 N+1번째에서 조회한 후보들은 N번째에선 조회하지 않음
 * 즉 모든 원소의 Stack 조회 횟수를 다 합해야 N이기 때문에 O(2N)의 시간복잡도를 가지게 됨
 */
class Solution {

	Stack<Integer> stack = new Stack<>();

	public int[] solution(int[] numbers) {

		stack.push(numbers[numbers.length - 1]);

		int[] answer = new int[numbers.length];
		answer[numbers.length - 1] = -1;

		for (int i = numbers.length - 2; i > -1; i--) {

			answer[i] = getBigger(numbers[i]);
			stack.push(numbers[i]);
		}

		return answer;
	}

	int getBigger(int now) {

		while (!stack.isEmpty()) {

			int candi = stack.pop();
			if (now < candi) {

				stack.push(candi);
				return candi;
			}
		}

		return -1;
	}
}