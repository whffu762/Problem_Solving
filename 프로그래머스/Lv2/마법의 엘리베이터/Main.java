/*
 * 생각해내는게 어려운 문제;;
 * 주목할 점
 * +-1 +-10 +-100 ... 으로 움직임
 * 이게 의미하는건 각 자릿수의 합으로 계산하라는 것임 처음엔 DP로 계산하라는 건줄 알았는데 점화식 쓰다 보니까 자릿수임을 알았음
 * 
 * 올림과 내림의 방식
 * 올림과 내림의 처리를 각 자릿수 별로 횟수를 올렸음
 * 즉 1의 자리부터 현재 자리 now가 5 이상이면 result += 10 - now + 1(올라간 후 내려가는 것을 계산) 이렇게 할 경우 998이 반례임
 * 8에서 3번 9에서 2번 9에서 2번 총 7번 연산으로 처리됨 근데 실제로는 3번임 (998 -> 999 -> 1000 -> 0) 
 * 현재 자리가 올라가면 다음 자리에까지 영향을 주기 때문에 이를 고려해야 함 이를 고려하기 위해 올라갈 경우 storey 값 자체에 올림을 해주는 식으로 해결해야 함 
 * 
 * 올림과 내림의 기준
 * 처음엔 0 1 2 3 4 5는 내리고 6 7 8 9는 올리는 식으로 계산하면 될 줄 알았음 
 * 5를 올린다면 5 -> 10 -> 0 총 6번 움직이고 내린다면 5 -> 0 5번 움직이기 때문임 근데 이게 반례가 존재함
 * 95의 경우 
 * 내린다면 95 -> 90 -> 100 -> 0 총 7번 움직임
 * 올린다면 95 -> 100 -> 0 총 6번 움직임
 * 
 * 65의 경우
 * 내린다면 65 -> 60 -> 100 -> 0 총 10번 움직임
 * 올린다면 65 -> 70 -> 100 -> 0 총 9번 움직임
 * 
 * 955의 경우
 * 내린다면 955 -> 950 -> 900 -> 1000 -> 0 총 12번 움직임
 * 올린다면 955 -> 960 -> 1000 -> 0 총 10번 움직임
 * 
 * 다음 자리가 5이상이면 현재 자리가 5일 때 올려야 함 그렇지 않은 경우엔 내림
 * 즉 5가 다음 자리의 값에 따라 움직임이 달라져야 함
 */
class Solution {
    
	public int solution(int storey) {
    
        int result = 0;
        while(storey != 0){
            
            int now = storey % 100;
            storey /= 10;
            
            int share = now / 10;
            int remain = now % 10;
            
            if(remain > 5 || (remain == 5 && share > 4)){
                result += 10 - remain;
                storey++;
                continue;
            }
            
            result += remain;
        }
        
        return result;
    }
}